**数据结构**
=

* **定义**
    1. 按某种逻辑关系将一批数据元素组织起来（逻辑结构）；
    2. 按一定的存储方式把它们存储起来（存储结构）；
    3. 在数据上定义一个运算集合（数据操作）；

* **逻辑结构**
    1. 线性结构
        * 特点：
            1. 结构中仅有一个起始点和终点；
            2. 起始点只有一个后继节点，终点只有一个前驱节点；
            3. 每个内节点有且仅有一个前驱节点和一个后继节点；
        * 举例：线性表
    2. 非线性结构
        * 特点：
            1. 结构中可能有多个前驱节点和多个后继节点；
        * 举例：数、图
* **存储结构**
    1. 顺序存储结构：数组
    2. 链式存储结构：链表

* **数据操作**
    1. 深度遍历
    2. 广度遍历


* **算法**
    1. 算法的特性：
        1. 有限性
        2. 确定性
        3. 输入
        4. 输出
        5. 可行性
    2. 评估算法的准则：
        1. 正确性
        2. 时间复杂性：O(1) < O(log<sub>2</sub>n) < O(n) < O(nlog<sub>2</sub>n) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>)
        3. 占用空间
        4. 可读性
        5. 坚固性
 
* **线性表**
    * 数组
        1. 插入
        
            ```c
            void insertItem(char arr[], char item)
            {
                int i = 0;
                while(arr[i] != '\0')
                {
                    i++;
                    if(i >= MAXSIZE)
                    {
                        printf("Array is full !\n");
                        break;
                    }
                }
                if (i < MAXSIZE)
                {
                    arr[i] = item;
                    arr[i+1] = '\0';//The array must be end with '\0'!
                }
            }
            ```
        2. 删除
           
           ```c
           void deleteItem(char *arr, char item)
            {
                int i = 0;
                while(arr[i] != '\0')
                {
                    if(arr[i] == item)
                    {
                        int j = i;
                        while(arr[j] != '\0')
                        {
                            arr[j] = arr[j+1];
                            j++;
                        }
                        i--;
                    }
                    i++;
                }
            }
           ```
        3. 查找
           
           ```c
           void searchItem(char *arr,char item)
            {
                int i = 0,count=0;
                while(arr[i] != '\0')
                {
                    if(arr[i] == item)
                    {
                        printf("arr[%d] ",i);
                        count++;
                    }
                    i++;
                }
                printf("\nfind %d '%c'\n",count,item);
            }
           ```
    * 链表
        1. 单链表
            1. 初始化
            
               ```c
               typedef struct ListNode{
                   char data[];
                   struct ListNode *next;
               } ListNode, *List;
               
               List InitLinkedList()
               {
                   ListNode *linkedList;
                   linkedList = (ListNode *)malloc(sizeof(ListNode));
                   if(linkedList == NULL)
                   {
                       printf("Init Failed!");
                       return NULL;
                   }
                   linkedList->next = NULL;
                   return linkedList;
               }
               ```
            2. 插入
               
               ```c
               void LinkedListInsert(List linkedList,int i,int item)
               {
                   int count = 0;
                   ListNode *node;
                   node = (ListNode *)malloc(sizeof(ListNode));
                   node->data = item;
                   node->next = NULL;
                   while(linkedList->next != NULL)
                   {
                       count++;
                       if(count == i)
                       {
                           node->next = linkedList->next;
                           linkedList->next = node;
                           break;
                       }
                       linkedList = linkedList->next;
                   }
                   if(i > count)
                   {
                       printf("Item is added at the end of the linkedList!\n");
                       linkedList->next = node;
                   }
               }
               ```
            3. 删除
               
               ```c
               void LinkedListDelete(List linkedList, int item)
               {
                   ListNode *node,*pre;
                   node = linkedList;
                   pre = linkedList;
                   node = node->next;
                   while(node != NULL)
                   {
                       if(node->data == item)
                       {
                           pre->next = node->next;
                           free(node);
                           node = pre->next;
                           continue;
                       }
                       pre = pre->next;
                       node = node->next;
                   }
               }
               ```
            4. 查找
               
               ```c
               void LinkedListSearch(List linkedList,int item)
              {
                   int count = 0;
                   ListNode *node;
                   node = linkedList;
                   while(node->next != NULL)
                   {
                       node = node->next;
                       if(node->data == item)
                           count++;
                   }
                   printf("Find %d '%d's !\n",count,item);
               }
               ```
        2. 循环链表
            1. 初始化
               
               ```c
               typedef struct ListNode
               {
                   int data;
                   struct ListNode *next;
               } ListNode, *List;
               
               List InitCircularList()
               {
                   ListNode *circularList;
                   circularList = (ListNode *)malloc(sizeof(ListNode));
                   if(circularList == NULL)
                   {
                       printf("Init Failed!");
                       return NULL;
                   }
                   circularList->next = circularList;
                   return circularList;
               }
               ```
            2. 插入

               ```c
               void CircularListInsert(List circularList,int i, int item)
               {
                   int count = 0;
                   ListNode *node, *temp;
                   node = (ListNode *)malloc(sizeof(ListNode));
                   node->data = item;
                   temp = circularList;
                   while(temp != NULL && temp->next != circularList)
                   {
                       count++;
                       if(count == i)
                       {
                           node->next = temp->next;
                           temp->next = node;
                           break;
                       }
                       temp = temp->next;
                   }
                   if(i > count)
                   {
                       node->next = circularList;
                       temp->next = node;
                   }
               }
               ```
            3. 删除
               
               ```c
               void CircularListDelete(List circularList, int item)
               {
                   ListNode *node, *pre;
                   node = circularList->next;
                   pre = circularList;
                   while(node != NULL && node != circularList)
                   {
                       if(node->data == item)
                       {
                           pre->next = node->next;
                           free(node);
                           node = pre->next;
                           continue;
                       }
                       pre = pre->next;
                       node = node->next;
                   }
               }
               ```
            4. 查找
               
               ```c
               void CircularListSearch(List circularList, int item)
               {
                   int count = 0;
                   ListNode *node;
                   node = circularList;
                   while(node != NULL && node->next != circularList)
                   {
                       node = node->next;
                       if(node->data == item)
                          count++;
                   }
                   printf("Find %d '%d's !",count,item);
               }
               ```
        3. 双向循环链表
            1. 初始化
               
               ```c
               typedef struct ListNode
               {
                   int data;
                   struct ListNode *pre;
                   struct ListNode *next;
               } ListNode, *List;
               
               List InitDoubleCircularList()
               {
                   ListNode *doubleCircularList;
                   doubleCircularList = (ListNode *)malloc(sizeof(ListNode));
                   if(doubleCircularList == NULL)
                   {
                       printf("Init Failed!");
                       return NULL;
                   }
                   doubleCircularList->pre = doubleCircularList;
                   doubleCircularList->next = doubleCircularList;
                   return doubleCircularList;
               }
               ```
            2. 插入
               
               ```c
               void DoubleCircularListInsert(List doubleCircularList, int i, int item)
               {
                   int count = 0;
                   ListNode *node, *temp;
                   node = (ListNode *)malloc(sizeof(ListNode));
                   node->data = item;
                   temp = doubleCircularList;
                   while(temp != NULL && temp->next != doubleCircularList)
                   {
                       count++;
                       if(count == i)
                       {
                           node->next = temp->next;
                           node->next->pre = node;
                           temp->next = node;
                           node->pre = temp;
                           break;
                       }
                       temp = temp->next;
                   }
                   if(i > count)
                   {
                       doubleCircularList->pre->next = node;
                       node->next = doubleCircularList;
                       node->pre = doubleCircularList->pre;
                       doubleCircularList->pre = node;
                   }
               }
               ```
            3. 删除
               
               ```c
               void DoubleCircularListDelete(List doubleCircularList,int item)
               {
                   ListNode *node, *pre;
                   node = doubleCircularList->next;
                   pre = doubleCircularList;
                   while(node != NULL && node != doubleCircularList)
                   {
                       if(node->data == item)
                       {
                           pre->next = node->next;
                           node->next->pre = pre;
                           free(node);
                           node = pre->next;
                           continue;
                       }
                       pre = pre->next;
                       node = node->next;
                   }
               }
               ```
            4. 查找
            
               ```c
               void DoubleCircularListSearch(List doubleCircularList, int item)
               {
                   int count = 0;
                   ListNode *node;
                   node = doubleCircularList;
                   while(node != NULL && node->next != doubleCircularList)
                   {
                       node = node->next;
                       if(node->data == item)
                       {
                           count++;
                       }
                   }
                   printf("Find %d '%d's !",count,item);
               }
               ```
    * 堆栈
        1. 入栈（Push）
           
           ```c
           Stacks Push(Stacks stacks,int item)
           {
               StackNode *node;
               node = (StackNode *)malloc(sizeof(StackNode));
               if(!node)
               {
                   printf("Create node failed !");
                   return NULL;
               }
               node->data = item;
               node->next = stacks;
               stacks = node;
               return stacks;
           }
           ```
        2. 出栈（Pop）
           
           ```c
           Stacks Pop(Stacks stacks)
           {
               StackNode *node;
               node = stacks;
               stacks = stacks->next;
               free(node);
               return stacks;
           }
           ```
        3. 删除
            
           ```c
           //First in last out
           Stacks Del(Stacks stacks, int item)
           {
               Stacks temp = NULL;
               StackNode *node, *t;
               node = stacks;
               int i = 0;
               while(node != NULL)
               {
                   if(node->data == item)
                   {
                       t = node;
                       node = node->next;
                       free(t);
                   }
                   else
                   {
                       t = node;
                       node = node->next;
                       t->next = temp;
                       temp = t;
                   }
               }
               stacks = node;
               while(temp != NULL)
               {
                   t = temp;
                   temp = temp->next;
                   t->next = stacks;
                   stacks = t;
               }
               return stacks;
           }
           ```
    * 队列
        1. 入队
        2. 出队

* **树**